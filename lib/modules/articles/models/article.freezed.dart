// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'article.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Article _$ArticleFromJson(Map<String, dynamic> json) {
  return _Article.fromJson(json);
}

/// @nodoc
mixin _$Article {
  String get uri => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;
  int get id => throw _privateConstructorUsedError;
  int get assetId => throw _privateConstructorUsedError;
  String get source => throw _privateConstructorUsedError;
  String get publishedDate => throw _privateConstructorUsedError;
  String get updated => throw _privateConstructorUsedError;
  String get section => throw _privateConstructorUsedError;
  String get subSection => throw _privateConstructorUsedError;
  String get nytdsection => throw _privateConstructorUsedError;
  String get adxKeywords => throw _privateConstructorUsedError;
  String get byline => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get abstract => throw _privateConstructorUsedError;
  List<String> get desFacet => throw _privateConstructorUsedError;
  List<String> get orgFacet => throw _privateConstructorUsedError;
  List<String> get perFacet => throw _privateConstructorUsedError;
  List<String> get geoFacet => throw _privateConstructorUsedError;
  List<Media> get media => throw _privateConstructorUsedError;
  int get etaId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ArticleCopyWith<Article> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ArticleCopyWith<$Res> {
  factory $ArticleCopyWith(Article value, $Res Function(Article) then) =
      _$ArticleCopyWithImpl<$Res, Article>;
  @useResult
  $Res call(
      {String uri,
      String url,
      int id,
      int assetId,
      String source,
      String publishedDate,
      String updated,
      String section,
      String subSection,
      String nytdsection,
      String adxKeywords,
      String byline,
      String type,
      String title,
      String abstract,
      List<String> desFacet,
      List<String> orgFacet,
      List<String> perFacet,
      List<String> geoFacet,
      List<Media> media,
      int etaId});
}

/// @nodoc
class _$ArticleCopyWithImpl<$Res, $Val extends Article>
    implements $ArticleCopyWith<$Res> {
  _$ArticleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uri = null,
    Object? url = null,
    Object? id = null,
    Object? assetId = null,
    Object? source = null,
    Object? publishedDate = null,
    Object? updated = null,
    Object? section = null,
    Object? subSection = null,
    Object? nytdsection = null,
    Object? adxKeywords = null,
    Object? byline = null,
    Object? type = null,
    Object? title = null,
    Object? abstract = null,
    Object? desFacet = null,
    Object? orgFacet = null,
    Object? perFacet = null,
    Object? geoFacet = null,
    Object? media = null,
    Object? etaId = null,
  }) {
    return _then(_value.copyWith(
      uri: null == uri
          ? _value.uri
          : uri // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as int,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
      publishedDate: null == publishedDate
          ? _value.publishedDate
          : publishedDate // ignore: cast_nullable_to_non_nullable
              as String,
      updated: null == updated
          ? _value.updated
          : updated // ignore: cast_nullable_to_non_nullable
              as String,
      section: null == section
          ? _value.section
          : section // ignore: cast_nullable_to_non_nullable
              as String,
      subSection: null == subSection
          ? _value.subSection
          : subSection // ignore: cast_nullable_to_non_nullable
              as String,
      nytdsection: null == nytdsection
          ? _value.nytdsection
          : nytdsection // ignore: cast_nullable_to_non_nullable
              as String,
      adxKeywords: null == adxKeywords
          ? _value.adxKeywords
          : adxKeywords // ignore: cast_nullable_to_non_nullable
              as String,
      byline: null == byline
          ? _value.byline
          : byline // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      abstract: null == abstract
          ? _value.abstract
          : abstract // ignore: cast_nullable_to_non_nullable
              as String,
      desFacet: null == desFacet
          ? _value.desFacet
          : desFacet // ignore: cast_nullable_to_non_nullable
              as List<String>,
      orgFacet: null == orgFacet
          ? _value.orgFacet
          : orgFacet // ignore: cast_nullable_to_non_nullable
              as List<String>,
      perFacet: null == perFacet
          ? _value.perFacet
          : perFacet // ignore: cast_nullable_to_non_nullable
              as List<String>,
      geoFacet: null == geoFacet
          ? _value.geoFacet
          : geoFacet // ignore: cast_nullable_to_non_nullable
              as List<String>,
      media: null == media
          ? _value.media
          : media // ignore: cast_nullable_to_non_nullable
              as List<Media>,
      etaId: null == etaId
          ? _value.etaId
          : etaId // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ArticleImplCopyWith<$Res> implements $ArticleCopyWith<$Res> {
  factory _$$ArticleImplCopyWith(
          _$ArticleImpl value, $Res Function(_$ArticleImpl) then) =
      __$$ArticleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String uri,
      String url,
      int id,
      int assetId,
      String source,
      String publishedDate,
      String updated,
      String section,
      String subSection,
      String nytdsection,
      String adxKeywords,
      String byline,
      String type,
      String title,
      String abstract,
      List<String> desFacet,
      List<String> orgFacet,
      List<String> perFacet,
      List<String> geoFacet,
      List<Media> media,
      int etaId});
}

/// @nodoc
class __$$ArticleImplCopyWithImpl<$Res>
    extends _$ArticleCopyWithImpl<$Res, _$ArticleImpl>
    implements _$$ArticleImplCopyWith<$Res> {
  __$$ArticleImplCopyWithImpl(
      _$ArticleImpl _value, $Res Function(_$ArticleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uri = null,
    Object? url = null,
    Object? id = null,
    Object? assetId = null,
    Object? source = null,
    Object? publishedDate = null,
    Object? updated = null,
    Object? section = null,
    Object? subSection = null,
    Object? nytdsection = null,
    Object? adxKeywords = null,
    Object? byline = null,
    Object? type = null,
    Object? title = null,
    Object? abstract = null,
    Object? desFacet = null,
    Object? orgFacet = null,
    Object? perFacet = null,
    Object? geoFacet = null,
    Object? media = null,
    Object? etaId = null,
  }) {
    return _then(_$ArticleImpl(
      uri: null == uri
          ? _value.uri
          : uri // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as int,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String,
      publishedDate: null == publishedDate
          ? _value.publishedDate
          : publishedDate // ignore: cast_nullable_to_non_nullable
              as String,
      updated: null == updated
          ? _value.updated
          : updated // ignore: cast_nullable_to_non_nullable
              as String,
      section: null == section
          ? _value.section
          : section // ignore: cast_nullable_to_non_nullable
              as String,
      subSection: null == subSection
          ? _value.subSection
          : subSection // ignore: cast_nullable_to_non_nullable
              as String,
      nytdsection: null == nytdsection
          ? _value.nytdsection
          : nytdsection // ignore: cast_nullable_to_non_nullable
              as String,
      adxKeywords: null == adxKeywords
          ? _value.adxKeywords
          : adxKeywords // ignore: cast_nullable_to_non_nullable
              as String,
      byline: null == byline
          ? _value.byline
          : byline // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      abstract: null == abstract
          ? _value.abstract
          : abstract // ignore: cast_nullable_to_non_nullable
              as String,
      desFacet: null == desFacet
          ? _value._desFacet
          : desFacet // ignore: cast_nullable_to_non_nullable
              as List<String>,
      orgFacet: null == orgFacet
          ? _value._orgFacet
          : orgFacet // ignore: cast_nullable_to_non_nullable
              as List<String>,
      perFacet: null == perFacet
          ? _value._perFacet
          : perFacet // ignore: cast_nullable_to_non_nullable
              as List<String>,
      geoFacet: null == geoFacet
          ? _value._geoFacet
          : geoFacet // ignore: cast_nullable_to_non_nullable
              as List<String>,
      media: null == media
          ? _value._media
          : media // ignore: cast_nullable_to_non_nullable
              as List<Media>,
      etaId: null == etaId
          ? _value.etaId
          : etaId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$ArticleImpl with DiagnosticableTreeMixin implements _Article {
  const _$ArticleImpl(
      {this.uri = '',
      this.url = '',
      this.id = 0,
      this.assetId = 0,
      this.source = '',
      this.publishedDate = '',
      this.updated = '',
      this.section = '',
      this.subSection = '',
      this.nytdsection = '',
      this.adxKeywords = '',
      this.byline = '',
      this.type = '',
      this.title = '',
      this.abstract = '',
      final List<String> desFacet = const <String>[],
      final List<String> orgFacet = const <String>[],
      final List<String> perFacet = const <String>[],
      final List<String> geoFacet = const <String>[],
      final List<Media> media = const <Media>[],
      this.etaId = 0})
      : _desFacet = desFacet,
        _orgFacet = orgFacet,
        _perFacet = perFacet,
        _geoFacet = geoFacet,
        _media = media;

  factory _$ArticleImpl.fromJson(Map<String, dynamic> json) =>
      _$$ArticleImplFromJson(json);

  @override
  @JsonKey()
  final String uri;
  @override
  @JsonKey()
  final String url;
  @override
  @JsonKey()
  final int id;
  @override
  @JsonKey()
  final int assetId;
  @override
  @JsonKey()
  final String source;
  @override
  @JsonKey()
  final String publishedDate;
  @override
  @JsonKey()
  final String updated;
  @override
  @JsonKey()
  final String section;
  @override
  @JsonKey()
  final String subSection;
  @override
  @JsonKey()
  final String nytdsection;
  @override
  @JsonKey()
  final String adxKeywords;
  @override
  @JsonKey()
  final String byline;
  @override
  @JsonKey()
  final String type;
  @override
  @JsonKey()
  final String title;
  @override
  @JsonKey()
  final String abstract;
  final List<String> _desFacet;
  @override
  @JsonKey()
  List<String> get desFacet {
    if (_desFacet is EqualUnmodifiableListView) return _desFacet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_desFacet);
  }

  final List<String> _orgFacet;
  @override
  @JsonKey()
  List<String> get orgFacet {
    if (_orgFacet is EqualUnmodifiableListView) return _orgFacet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_orgFacet);
  }

  final List<String> _perFacet;
  @override
  @JsonKey()
  List<String> get perFacet {
    if (_perFacet is EqualUnmodifiableListView) return _perFacet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_perFacet);
  }

  final List<String> _geoFacet;
  @override
  @JsonKey()
  List<String> get geoFacet {
    if (_geoFacet is EqualUnmodifiableListView) return _geoFacet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_geoFacet);
  }

  final List<Media> _media;
  @override
  @JsonKey()
  List<Media> get media {
    if (_media is EqualUnmodifiableListView) return _media;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_media);
  }

  @override
  @JsonKey()
  final int etaId;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Article(uri: $uri, url: $url, id: $id, assetId: $assetId, source: $source, publishedDate: $publishedDate, updated: $updated, section: $section, subSection: $subSection, nytdsection: $nytdsection, adxKeywords: $adxKeywords, byline: $byline, type: $type, title: $title, abstract: $abstract, desFacet: $desFacet, orgFacet: $orgFacet, perFacet: $perFacet, geoFacet: $geoFacet, media: $media, etaId: $etaId)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Article'))
      ..add(DiagnosticsProperty('uri', uri))
      ..add(DiagnosticsProperty('url', url))
      ..add(DiagnosticsProperty('id', id))
      ..add(DiagnosticsProperty('assetId', assetId))
      ..add(DiagnosticsProperty('source', source))
      ..add(DiagnosticsProperty('publishedDate', publishedDate))
      ..add(DiagnosticsProperty('updated', updated))
      ..add(DiagnosticsProperty('section', section))
      ..add(DiagnosticsProperty('subSection', subSection))
      ..add(DiagnosticsProperty('nytdsection', nytdsection))
      ..add(DiagnosticsProperty('adxKeywords', adxKeywords))
      ..add(DiagnosticsProperty('byline', byline))
      ..add(DiagnosticsProperty('type', type))
      ..add(DiagnosticsProperty('title', title))
      ..add(DiagnosticsProperty('abstract', abstract))
      ..add(DiagnosticsProperty('desFacet', desFacet))
      ..add(DiagnosticsProperty('orgFacet', orgFacet))
      ..add(DiagnosticsProperty('perFacet', perFacet))
      ..add(DiagnosticsProperty('geoFacet', geoFacet))
      ..add(DiagnosticsProperty('media', media))
      ..add(DiagnosticsProperty('etaId', etaId));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ArticleImpl &&
            (identical(other.uri, uri) || other.uri == uri) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.publishedDate, publishedDate) ||
                other.publishedDate == publishedDate) &&
            (identical(other.updated, updated) || other.updated == updated) &&
            (identical(other.section, section) || other.section == section) &&
            (identical(other.subSection, subSection) ||
                other.subSection == subSection) &&
            (identical(other.nytdsection, nytdsection) ||
                other.nytdsection == nytdsection) &&
            (identical(other.adxKeywords, adxKeywords) ||
                other.adxKeywords == adxKeywords) &&
            (identical(other.byline, byline) || other.byline == byline) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.abstract, abstract) ||
                other.abstract == abstract) &&
            const DeepCollectionEquality().equals(other._desFacet, _desFacet) &&
            const DeepCollectionEquality().equals(other._orgFacet, _orgFacet) &&
            const DeepCollectionEquality().equals(other._perFacet, _perFacet) &&
            const DeepCollectionEquality().equals(other._geoFacet, _geoFacet) &&
            const DeepCollectionEquality().equals(other._media, _media) &&
            (identical(other.etaId, etaId) || other.etaId == etaId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        uri,
        url,
        id,
        assetId,
        source,
        publishedDate,
        updated,
        section,
        subSection,
        nytdsection,
        adxKeywords,
        byline,
        type,
        title,
        abstract,
        const DeepCollectionEquality().hash(_desFacet),
        const DeepCollectionEquality().hash(_orgFacet),
        const DeepCollectionEquality().hash(_perFacet),
        const DeepCollectionEquality().hash(_geoFacet),
        const DeepCollectionEquality().hash(_media),
        etaId
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ArticleImplCopyWith<_$ArticleImpl> get copyWith =>
      __$$ArticleImplCopyWithImpl<_$ArticleImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ArticleImplToJson(
      this,
    );
  }
}

abstract class _Article implements Article {
  const factory _Article(
      {final String uri,
      final String url,
      final int id,
      final int assetId,
      final String source,
      final String publishedDate,
      final String updated,
      final String section,
      final String subSection,
      final String nytdsection,
      final String adxKeywords,
      final String byline,
      final String type,
      final String title,
      final String abstract,
      final List<String> desFacet,
      final List<String> orgFacet,
      final List<String> perFacet,
      final List<String> geoFacet,
      final List<Media> media,
      final int etaId}) = _$ArticleImpl;

  factory _Article.fromJson(Map<String, dynamic> json) = _$ArticleImpl.fromJson;

  @override
  String get uri;
  @override
  String get url;
  @override
  int get id;
  @override
  int get assetId;
  @override
  String get source;
  @override
  String get publishedDate;
  @override
  String get updated;
  @override
  String get section;
  @override
  String get subSection;
  @override
  String get nytdsection;
  @override
  String get adxKeywords;
  @override
  String get byline;
  @override
  String get type;
  @override
  String get title;
  @override
  String get abstract;
  @override
  List<String> get desFacet;
  @override
  List<String> get orgFacet;
  @override
  List<String> get perFacet;
  @override
  List<String> get geoFacet;
  @override
  List<Media> get media;
  @override
  int get etaId;
  @override
  @JsonKey(ignore: true)
  _$$ArticleImplCopyWith<_$ArticleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
